SPLOIT 1:

THE PROBLEM:

The program has a function that contains a buffer that we copy a supplied
string, from args[1], into. The function foo calls the function bar, which 
contains strcpy(). This method does not have bounds checking for any string 
passed as a parameter into it. This means that there is a buffer overflow 
coding error within the program. When strcpy() copies our string into the 
buffer, it won't stop when the buffer is filled. It will continue to 
copy elements of the string until it reaches the '\0' in our supplied string.
This means that addresses closeby to the buffer's address may be corrupted. 

THE EXPLOIT:

STACK --> [ buffer ] [ saved ebp ] [ saved eip ] [ arg1-N ]

The above is a visual representation of our stack when we call our function
with the buffer overflow coding error. What the attacker can do here is 
change the saved eip in order to alter the flow of execution to their 
advantage. How does this work? Lets see what happens when we copy more 
bytes from our string 'A' <200+ times> into a buffer that can only contain
around 100 bytes. What happens is that 'A' will be filled within the buffer,
saved ebp, saved eip, etc. When the function returns, the program will 
attempt to be directed to an address that was corrupted, and thus 
give a segmentation fault. This leads us to the exploitation. What the
attacker can do is fill the buffer with their own shellcode, figure out 
where the saved eip is located, and replace the saved eip location with
the memory address of the shellcode. When the function returns, it will
direct the program's execution to the location of the shellcode. This 
allows the attacker to gain control.

STACK --> [ shellcode ] [ junk ] [ &shellcode ] [ arg1-N ]
