SPLOIT 3:

EXPLOIT:

First off we examine what we know so far. Our widget_t struct has size of
32 bytes (3 doubles that are 8 bytes and 2 ints that are 4 bytes). The maximum 
size of buf is therfore (583 * 32 = 18656) bytes, where 32 is the size of the 
widget_t struct and 583 is the size of our array. This means we have to pass
an input data that is longer than 18656 in order to overflow. Our input string
will be in the format "<count>,<data>" where count represents the amount of widget_t
and data represents what we will fill the buf with. 

The problem we have to overcome is the check in foo that will skip the memcpy method
if "count >= MAX_WIDGETS". To exploit this we figured out the MAX value of int, which
is 2,147,483,647. We added 601 to this value which creates a value that is out of range
of MAXINT. In foo, we multiply this value with the sizeof(struct widget_t), which
creates a really large negative number. Because this is out of the range of int, we 
wrap around to a positive number. This will allow us to pass the check and overflow
the buffer. 

STACK --> [     -local_var-      ][   -ebp-   ][   -eip-   ][       -params-        ]
          [<shellcode>...........][AAAAAAAAAAA][50|6a|ff|bf][AAAAAAAAAAAAAAAAAAAAAAS]

Looking at our stack, we overwrite the eip of the section to point to our &shellcode.
This gives us access.
