SPLOIT 1:

THE PROBLEM:

The program has a few functions, but we will look at the functions bar() and 
nstrcpy(). Function bar() will call nstrcpy() with 3 arguments: out, outl, and in.
The variable 'out' represents the buffer that we will write into, 'outl' represents
the length of the buffer, and 'in' represents the string supplied by the attacker. 
The difference between target2 and target1 is the fact that we now have tighter 
constraint than we did in target1. We are only able to overflow the target buffer 
by one byte. But, this won't stop the attacker from being able to gain direct control.
As we will see, this demonstrates that it is still possible to exploit such a vulnerability
even under the worst conditions.
 

THE EXPLOIT:

STACK BEFORE OVERFLOW --> [ buffer ] [ saved ebp ] [ saved eip ]

The above is a visual representation of our stack before we overflow the buffer by one byte.
What we are concerned with is the saved ebp pointer. After the function is called and 
returns, %ebp will be popped off the stack and restored into %esp. This means we can 
modify the %esp pointer in some way.  After overflowing the buffer by a value like 0x41,
%ebp will be restored into %esp, incremented by 4, and now the %esp value will be 
old %esp value + 0x41 = new %esp value. So how does this help the attacker, if they 
cannot directly change the value of the %eip pointer? Well, what the attacker can do is 
make the processor think that it is somewhere else, and by doing this gain control. How 
does that work? The processor will pop the first word on the stack on the assumption that 
this is the original %eip. If the attacker can change the %esp pointer, they can potentially
do a redirection and pop a pointer to their shellcode as if it were the %eip. 

STACK BEFORE OVERFLOW --> [ nops ] [ shellcode ] [ &shellcode ] [ %ebp_altering_byte ] [ saved eip ]

The above is a visual representation of how the stack looks like with the malicious code
supplied by the attacker. What the attacker wants is the %esp pointer to point to the 
address of the shellcode and thus tricking the program into thinking that the address 
supplied is actually the %eip pointer. The &shellcode can potentially point anywhere within the 
nops so that execution will just continue until it reaches the shellcode. In our implementation
we did not necessarily place the nops before the shellcode, but as long as $shellcode points to
the shellcode, it will work. Finally the attacker now has gained control. GG.
