SPLOIT 4:

EXPLOIT:

This exploit is different from how we would normally do a buffer overflow. This means
we have to figure out how to exploit the program a different way. What we noticed 
is that in target4.c we call tfree(q) twice. At this point we have allocated 
1024 bytes for p, and filled the buf with our own input string. Our q is pointing 
within p's address space as well. If we observe the address space of foo and p, we
notice that we will indeed have difficulty in overflowing because the difference is 
too great. So we will have to work with the tfree exploit.

CHUNK --> [left pointer][right pointer][data]

Looking at the code for tfree(q) we can see that we will move around the pointers of 
some CHUNKS. This is where we exploit the program. In tfree q is represented by p. So we 
will think of the CHUNKS in this way. When we called obsd_strlcpy() we overwrit some
bytes, some of which included left and right pointers of p (in tfree). What we wanted 
to do is specifically overwrite p's (tfree) left pointer to point to q (tfree), which
contains our shellcode, and p's (tfree) right pointer to point to the eip. This will
make eip contain the &shellcode. 

[   left    |   right   ][data...             ][   left    |   right   ][data...        ]
[90|90|eb|03|4d|fa|ff|bf][90|...<shellcode>...][48|9a|04|08|4c|fa|ff|bf][xx|.........|00]
                <q>                                             <p>

The above image shows a representation of p and q in tfree during the exploit. As you can
see, p's right pointer is pointing to the eip, and its left pointer is pointing to the 
data section of q, where the shellcode is. When the return happens, it will go straight to 
the data section, go through the nops, and execute the code. The jump instruction is used
to jump past some bytes in right pointer of q, since it will mess up up the flow. 